<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LOLCowNerds Can't Jump</title>
<style>
  :root{
    --bg:#141228; --panel:#171333; --ink:#eef1ff;
    --purple:#9440ff; --magenta:#ff4bd8; --cyan:#5effea; --rim:#2b2754;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:Inter,ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,"Trebuchet MS",sans-serif}

  .wrap{display:grid;place-items:center;min-height:100vh;padding-top:64px}

  .brand{
    position:fixed; top:10px; left:0; right:0; text-align:center;
    margin:0; font-weight:900; letter-spacing:.3px;
    font-size:clamp(20px,3vw,28px);
    color:var(--magenta); text-shadow:0 2px 0 #000, 0 0 14px #5effea66;
    pointer-events:none;
  }

  canvas{
    width:min(92vw,740px); height:calc(min(92vw,740px)*1.5);
    image-rendering:pixelated; border-radius:14px; border:3px solid var(--rim);
    box-shadow:0 0 0 3px #0006 inset,0 10px 40px #0008,0 0 0 2px var(--cyan),0 0 0 6px #9436ff55,0 0 22px 4px #59fff066 inset;
    background:#0c0a19 url(jump/bg_soft.png) repeat; /* seamless soft bg */
  }

  /* HUD */
  #hud{
    position:fixed; left:12px; top:56px;
    display:flex; gap:10px; align-items:center;
    background:#0d0a22cc; border:2px solid var(--rim); border-radius:12px;
    padding:8px 12px; font-weight:800; text-shadow:0 1px 0 #000;
    box-shadow:0 0 0 2px #0006 inset,0 0 16px #5effea44;
  }
  .pill{background:#1b1740;border:1px solid #3d3773;padding:4px 8px;border-radius:9px}
  .pill b{color:var(--cyan)} .pill.high b{color:var(--magenta)}
  .pill.level b{color:#ffd36b}

  /* Overlay */
  .overlay{position:fixed; inset:0; display:grid; place-items:center;
    background:radial-gradient(1200px 700px at 50% 12%, #0000, #000c)}
  .overlay[hidden]{display:none !important;}
  .panel{
    background:var(--panel); border:2px solid var(--rim); border-radius:16px;
    padding:16px; width:min(92vw,720px);
    box-shadow:0 12px 50px #000a, inset 0 0 0 2px #0006;
  }
  .panel h1{margin:0 0 8px; font-size:clamp(22px,2.6vw,28px); color:var(--magenta)}
  .panel p{margin:6px 0 12px; opacity:.9}

  .choose{display:flex; gap:14px; flex-wrap:wrap; margin:10px 0 14px}
  .card{
    border:2px solid var(--rim); background:#16132b; border-radius:12px;
    padding:10px; cursor:pointer; transition:transform .06s ease;
    box-shadow:inset 0 0 0 2px #0006
  }
  .card:hover{transform:translateY(-2px)} .card.selected{outline:3px solid var(--cyan)}
  .card img{image-rendering:pixelated; width:96px; height:96px; display:block}

  button.primary{
    background:linear-gradient(180deg, var(--cyan), #0cc3a6);
    color:#04110f; border:0; border-radius:10px; font-weight:900;
    padding:10px 16px; cursor:pointer; box-shadow:0 6px 0 #007a63
  }
  button.primary:active{transform:translateY(2px); box-shadow:0 4px 0 #007a63}

  #tips{font-size:13px; opacity:.9}
  #tips kbd{background:#222044; padding:2px 6px; border-radius:6px; border:1px solid #3a376e}
</style>
</head>
<body>
<h1 class="brand">LOLCowNerds Can't Jump</h1>

<div class="wrap">
  <canvas id="game" width="480" height="720"></canvas>

  <div id="hud">
    <div class="pill">Height: <b id="heightFt">0</b> ft</div>
    <div class="pill high">High: <b id="highFt">0</b> ft</div>
    <div class="pill">Score: <b id="score">0</b></div>
    <div class="pill level">Level: <b id="level">0</b></div>
  </div>

  <!-- Start / Pause Overlay -->
  <div id="overlay" class="overlay" hidden>
    <div class="panel">
      <h1 id="ov-title">Nerd Jump</h1>
      <p id="ov-msg">Pick your host. Every <b>500 ft</b> = new level (harder but fair). Press <kbd>Enter</kbd>/<kbd>Space</kbd> to start, <kbd>R</kbd> to refresh.</p>

      <div class="choose" id="choose">
        <div class="card selected" data-hero="zey">
          <img src="jump/host_zey_hd.png" alt="Zey" />
          <div><b>Zey</b><div style="opacity:.8;font-size:12px">HD sprite</div></div>
        </div>
        <div class="card" data-hero="buff">
          <img src="jump/host_buff_hd.png" alt="Buff" />
          <div><b>Buff</b><div style="opacity:.8;font-size:12px">HD sprite</div></div>
        </div>
      </div>

      <div class="row">
        <button id="startBtn" class="primary">Start Game</button>
        <button id="restartBtn" class="primary" style="display:none">Restart</button>
        <span id="tips">
          &nbsp;&nbsp;<kbd>A</kbd>/<kbd>D</kbd> or <kbd>←</kbd>/<kbd>→</kbd> move ·
          <kbd>Space</kbd>/<kbd>W</kbd>/<kbd>↑</kbd> jump · <kbd>Enter</kbd>/<kbd>Space</kbd> start
        </span>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ------------ Setup ------------
  const CANVAS = document.getElementById('game');
  const CTX = CANVAS.getContext('2d'); CTX.imageSmoothingEnabled = false;

  const IMG = {
    zeyRight: loadImage('jump/host_zey_hd.png'),
    buffRight: loadImage('jump/host_buff_hd.png'),
    ground:   loadImage('jump/platform_ground.png'),
    platforms:[
      loadImage('jump/platform_circuit.png'),
      loadImage('jump/platform_vapor.png'),
      loadImage('jump/platform_cyan.png'),
      loadImage('jump/platform_cloud.png'),
      loadImage('jump/platform_floppy.png')
    ],
    bunker: loadImage('jump/bunker.png'),
    flag:   loadImage('jump/ndf_flag.png'),
  };

  // Tuning
  const FT_PER_STEP = 5, PTS_PER_STEP = 5, PIXELS_PER_FOOT = 6;
  const GRAVITY = 0.5, MOVE_SPEED = 3.0;
  const JUMP_V = -12.8, JUMP_RUN_BONUS = -1.4;

  const BASE_GAP_MIN = 70, BASE_GAP_MAX = 120;
  const PLATFORM_W = 64, PLATFORM_H = 18;

  const TOP_ZONE = 0.35, BOTTOM_ZONE = 0.70; // camera dead-zone

  // HUD elements
  const hudHeightFt = document.getElementById('heightFt');
  const hudHighFt   = document.getElementById('highFt');
  const hudScore    = document.getElementById('score');
  const hudLevel    = document.getElementById('level');

  // Overlay UI
  const overlay   = document.getElementById('overlay');
  const startBtn  = document.getElementById('startBtn');
  const restartBtn= document.getElementById('restartBtn');
  const chooseEl  = document.getElementById('choose');

  // Game state
  let hero = 'zey';
  let player, platforms = [], groundPlat, baseCamp500 = null;
  let keys = {};
  let scrollPixels = 0, startYRef = 0, lastTimeMs = 0, rafId = null, gameRunning = false;
  let highFeet = parseInt(localStorage.getItem('nerd_jump_high_feet') || '0', 10);
  let baseCampSpawned = false;

  // ------------ Utilities ------------
  function loadImage(src){ const im=new Image(); im.src=src; return im; }
  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function currentAltitudePixels(){ return scrollPixels + (startYRef - player.y); }
  function altitudeFeet(){ return Math.max(0, Math.floor(currentAltitudePixels()/PIXELS_PER_FOOT)); }
  function stepsFromFeet(ft){ return Math.floor(ft / FT_PER_STEP); }
  function scoreFromFeet(ft){ return stepsFromFeet(ft) * PTS_PER_STEP; }

  function currentLevel(feet){ return Math.floor(feet / 500); }

  // Difficulty per level (platforms 50% faster than previous build)
  function diffFor(level){
    return {
      gapMin: BASE_GAP_MIN + level * 6,
      gapMax: BASE_GAP_MAX + level * 10,
      moveSpeedMult: 3.375 * (1 + level * 0.12), // 2.25 * 1.5
      breakableChance: Math.min(0.25 + level * 0.06, 0.6)
    };
  }

  // ------------ Classes ------------
  class Player{
    constructor(sprite){
      this.spriteSize=96;
      this.spriteFootOffset=Math.round(this.spriteSize*0.25);
      this.w=40; this.h=60;

      this.x=CANVAS.width/2; this.y=CANVAS.height - 70;
      this.vx=0; this.vy=0; this.onGround=true; this.facing=1;
      this.sprite=sprite;
      this.onPlatform = null; // for riding movers
    }
    get feet(){ return this.y + this.h/2; }
    get head(){ return this.y - this.h/2; }

    update(){
      // Movement input
      this.vx = 0;
      if (keys['a'] || keys['arrowleft'])  { this.vx -= MOVE_SPEED; this.facing = -1; }
      if (keys['d'] || keys['arrowright']) { this.vx += MOVE_SPEED; this.facing =  1; }

      this.vy += GRAVITY;
      this.x  += this.vx;
      this.y  += this.vy;

      // Horizontal wrap
      const hw = this.w/2;
      if (this.x < -hw) this.x = CANVAS.width + hw;
      if (this.x > CANVAS.width + hw) this.x = -hw;

      // Clear riding unless we prove we are still standing this frame
      let ridingThisFrame = false;

      // Platform landing / riding (only on solid)
      const colliders = [groundPlat, ...platforms];
      if (this.vy > 0){
        for (const p of colliders){
          if (!p.isSolid()) continue;
          const top=p.top(), left=p.left(), right=p.right();
          if (this.feet >= top && (this.feet - this.vy) <= top && this.x >= left && this.x <= right){
            this.y = top - this.h/2;
            this.vy = 0;
            this.onGround = true;
            p.landedOn(); // for crumble timer
            this.onPlatform = p !== groundPlat ? p : null; // ride movers but not infinite ground
            ridingThisFrame = !!this.onPlatform;
          }
        }
      }

      // Ride mover if still standing on it (carry by platform delta)
      if (this.onPlatform && this.onPlatform.isSolid()){
        const p = this.onPlatform;
        const top=p.top(), left=p.left(), right=p.right();
        if (Math.abs(this.feet - top) < 1.1 && this.x >= left && this.x <= right && this.vy >= -0.2){
          this.x += (p.dx || 0);
          this.y += (p.dy || 0);
          ridingThisFrame = true;
          this.onGround = true;
        }
      }
      if (!ridingThisFrame) this.onPlatform = null;

      // Wrap again after riding motion
      if (this.x < -hw) this.x = CANVAS.width + hw;
      if (this.x > CANVAS.width + hw) this.x = -hw;

      // Ground clamp
      const groundTop = groundPlat.top();
      if (this.feet > groundTop + 1){
        this.y = groundTop - this.h/2;
        this.vy = 0; this.onGround = true; this.onPlatform = null;
      }

      // Camera follow both directions
      const topTarget = CANVAS.height * TOP_ZONE;
      const bottomTarget = CANVAS.height * BOTTOM_ZONE;
      if (this.y < topTarget){
        const dy = topTarget - this.y;
        this.y += dy; scrollWorld(dy);
      } else if (this.y > bottomTarget){
        const dy = this.y - bottomTarget;
        this.y -= dy; scrollWorld(-dy);
      }
    }

    jump(){
      if (this.onGround || Math.abs(this.vy) < 0.1){
        const moving = (keys['a']||keys['d']||keys['arrowleft']||keys['arrowright']);
        this.vy = JUMP_V + (moving ? JUMP_RUN_BONUS : 0);
        this.onGround = false;
        this.onPlatform = null;
      }
    }

    draw(ctx){
      const S=this.spriteSize;
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(this.facing,1);
      const yTop = this.h/2 - S + this.spriteFootOffset;
      ctx.drawImage(this.sprite, -S/2, yTop, S, S);
      ctx.restore();
    }
  }

  class Platform{
    // moveX/moveY: amplitudes; speed: base time speed multiplier (seconds)
    constructor(img,x,y,w=PLATFORM_W,h=PLATFORM_H,moveX=0,moveY=0,speed=0,phase=Math.random()*Math.PI*2,tileRepeat=false, breakable=false, fallAfter=3, decor=null){
      this.baseX=x; this.baseY=y; this.x=x; this.y=y; this.w=w; this.h=h;
      this.img=img; this.moveX=moveX; this.moveY=moveY; this.speed=speed; this.phase=phase;
      this.tileRepeat=tileRepeat;

      this.breakable = breakable; this.fallAfter = fallAfter;
      this.standTimer = 0; this.falling = false; this.fallVy = 0;

      this.dx = 0; this.dy = 0; // per-frame motion (not including camera scroll)
      this.decor = decor; // 'start' ground or 'camp'
    }
    isSolid(){ return !this.falling; }
    landedOn(){ this._justLanded = true; }

    update(nowSec, dtSec, player){
      const oldX = this.x, oldY = this.y;

      if (this.moveX) this.x = this.baseX + Math.sin(nowSec*this.speed + this.phase) * this.moveX;
      if (this.moveY) this.y = this.baseY + Math.sin(nowSec*this.speed*0.9 + this.phase) * this.moveY;

      const standing = !!this._justLanded ||
        (Math.abs(player.feet - this.top()) < 1.05 && player.x >= this.left() && player.x <= this.right() && player.vy >= -0.2);

      if (this.breakable && !this.falling){
        if (standing) this.standTimer += dtSec; else this.standTimer = 0;
        if (this.standTimer >= this.fallAfter){ this.falling = true; this.fallVy = 0; }
      }
      if (this.falling){ this.y += this.fallVy; this.baseY += this.fallVy; this.fallVy += 0.35; }

      this._justLanded = false;

      // per-frame motion (excludes camera scroll because scroll happens after this)
      this.dx = this.x - oldX;
      this.dy = this.y - oldY;
    }

    draw(ctx){
      if (this.tileRepeat){
        const tileW = 128;
        for (let x=0; x<CANVAS.width+tileW; x+=tileW){
          ctx.drawImage(this.img, x - tileW/2, this.y - this.h/2, tileW, this.h);
        }
        // decorations for ground types
        if (this.decor === 'start') drawGroundStart(ctx, this.y, this.h);
        if (this.decor === 'camp')  drawBaseCamp(ctx, this.y, this.h);
      } else {
        ctx.drawImage(this.img, this.x - this.w/2, this.y - this.h/2, this.w, this.h);
      }

      // Breakable tint
      if (this.breakable && !this.falling){
        const t = clamp(this.standTimer / this.fallAfter, 0, 1);
        if (t > 0){
          ctx.save(); ctx.globalAlpha = 0.25 + 0.55*t; ctx.fillStyle = '#ff2e2e';
          ctx.fillRect(this.x - this.w/2, this.y - this.h/2, this.w, this.h); ctx.restore();
        }
      }
    }

    top(){ return this.y - this.h/2; }
    left(){ return this.tileRepeat ? 0 : (this.x - this.w/2); }
    right(){ return this.tileRepeat ? CANVAS.width : (this.x + this.w/2); }
  }

  // ----- Ground decorations -----
  function drawGroundStart(ctx, y, h){
    const top = y - h/2;
    ctx.save();
    ctx.font = "12px monospace"; ctx.textBaseline = "bottom";
    // Flags left/right
    drawFlag(ctx, 80, top);
    drawFlag(ctx, CANVAS.width-80, top);
    // Arrow + "Base Camp: 500 ft"
    const cx = CANVAS.width/2;
    ctx.fillStyle = "#5effea";
    ctx.fillRect(cx-2, top-26, 4, 20);
    ctx.beginPath(); ctx.moveTo(cx-8, top-26); ctx.lineTo(cx, top-36); ctx.lineTo(cx+8, top-26); ctx.closePath(); ctx.fill();
    ctx.fillStyle = "#eef1ff";
    const label = "Base Camp: 500 ft";
    ctx.fillText(label, cx - ctx.measureText(label).width/2, top-40);
    ctx.restore();
  }

  function drawBaseCamp(ctx, y, h){
    const top = y - h/2;
    ctx.save();
    const bw = IMG.bunker.width, bh = IMG.bunker.height;
    const bx = CANVAS.width/2 - bw/2; const by = top - bh; // sit on the ground
    ctx.drawImage(IMG.bunker, bx, by);

    // Flags flanking bunker
    drawFlag(ctx, bx - 30, top);
    drawFlag(ctx, bx + bw + 30, top);

    // Sign "NDF Base Camp" on/above bunker
    const text = "NDF Base Camp";
    ctx.font = "12px monospace"; ctx.textBaseline = "bottom";
    const tw = ctx.measureText(text).width;
    const sx = CANVAS.width/2 - tw/2 - 6, sy = by - 6;
    ctx.fillStyle = "#1b1740"; ctx.fillRect(sx-4, sy-18, tw+8, 18);
    ctx.strokeStyle = "#5effea"; ctx.strokeRect(sx-4, sy-18, tw+8, 18);
    ctx.fillStyle = "#eef1ff"; ctx.fillText(text, sx, sy-2);
    ctx.restore();
  }

  function drawFlag(ctx, px, top){
    const fh = IMG.flag.height, fw = IMG.flag.width;
    ctx.drawImage(IMG.flag, px, top - fh);
  }

  // ------------ World gen ------------
  function spawnInitialWorld(){
    platforms = [];

    const groundY = CANVAS.height - 20;
    groundPlat = new Platform(IMG.ground, CANVAS.width/2, groundY, CANVAS.width, 24, 0,0,0,0,true,false,3,'start');

    // starter ladder
    let y = groundY - 80;
    for (let i=0;i<4;i++){
      const x = (i%2===0) ? CANVAS.width*0.35 : CANVAS.width*0.65;
      platforms.push(new Platform(pickArt(), x, y));
      y -= 80;
    }

    // initial fill upwards
    let topY = y;
    while (topY > -200){
      topY -= rand(BASE_GAP_MIN, BASE_GAP_MAX);
      spawnRow(topY, 0);
    }
  }

  function spawnRow(y, level){
    const D = diffFor(level);
    const count = Math.random() < 0.3 ? 2 : 1;
    for (let i=0;i<count;i++){
      const x = rand(60, CANVAS.width - 60);
      const roll = Math.random();
      let moveX=0, moveY=0, speed=0;
      if (roll < 0.35){
        moveX = rand(15, 35) + level*3;
        speed = (0.25 + Math.random()*0.25) * D.moveSpeedMult;
      } else if (roll < 0.50){
        moveY = rand(12, 28) + level*2;
        speed = (0.20 + Math.random()*0.20) * D.moveSpeedMult;
      }
      const breakable = Math.random() < D.breakableChance;
      platforms.push(new Platform(pickArt(), x, y, PLATFORM_W, PLATFORM_H, moveX, moveY, speed, Math.random()*Math.PI*2, false, breakable, 3, null));
    }
  }

  function pickArt(){ return IMG.platforms[Math.floor(Math.random()*IMG.platforms.length)]; }

  function scrollWorld(dy){
    scrollPixels += dy;
    for (const p of platforms) { p.y += dy; p.baseY += dy; }
    groundPlat.y += dy; groundPlat.baseY += dy;
    if (baseCamp500){ baseCamp500.y += dy; baseCamp500.baseY += dy; }

    // Level-aware spawning
    const ft = altitudeFeet();
    const lvl = currentLevel(ft);
    const D = diffFor(lvl);

    // Inject 500-ft checkpoint once when you reach level 1
    if (!baseCampSpawned && lvl >= 1){
      const highest = Math.min(...platforms.map(p => p.y));
      const campY = highest - 140; // a bit above the top-most platforms
      baseCamp500 = new Platform(IMG.ground, CANVAS.width/2, campY, CANVAS.width, 24, 0,0,0,0,true,false,3,'camp');
      platforms.push(baseCamp500);
      baseCampSpawned = true;
    }

    // Cull + keep filling top
    platforms = platforms.filter(p => p.y < CANVAS.height + 60);
    while (true){
      const highest = Math.min(...platforms.map(p => p.y));
      if (highest > -80){
        const newY = highest - rand(D.gapMin, D.gapMax);
        spawnRow(newY, lvl);
      } else break;
    }
  }

  // ------------ Loop ------------
  function newGame(){
    baseCampSpawned = false; baseCamp500 = null;
    scrollPixels = 0;
    spawnInitialWorld();

    const sprite = (hero==='buff') ? IMG.buffRight : IMG.zeyRight;
    player = new Player(sprite);
    startYRef = player.y;

    hudHeightFt.textContent = '0';
    hudScore.textContent = '0';
    hudHighFt.textContent = highFeet;
    hudLevel.textContent = '0';
  }

  function startGame(){
    if (rafId) cancelAnimationFrame(rafId);
    overlay.hidden = true; gameRunning = true;
    lastTimeMs = performance.now();
    rafId = requestAnimationFrame(loop);
  }

  function loop(nowMs){
    if (!gameRunning) return;

    let dtSec = (nowMs - lastTimeMs)/1000;
    if (dtSec > 0.05) dtSec = 0.05;
    lastTimeMs = nowMs;

    const tSec = nowMs/1000;
    groundPlat.update(tSec, dtSec, player);
    for (const p of platforms) p.update(tSec, dtSec, player);
    player.update();

    // HUD
    const ft = altitudeFeet(), lvl = currentLevel(ft), score = scoreFromFeet(ft);
    if (ft > highFeet){ highFeet = ft; localStorage.setItem('nerd_jump_high_feet', String(highFeet)); }
    hudHeightFt.textContent = ft; hudHighFt.textContent = highFeet;
    hudScore.textContent = score; hudLevel.textContent = lvl;

    // Draw
    CTX.clearRect(0,0,CANVAS.width,CANVAS.height);
    groundPlat.draw(CTX);
    for (const p of platforms) p.draw(CTX);
    player.draw(CTX);

    rafId = requestAnimationFrame(loop);
  }

  // ------------ Input ------------
  window.addEventListener('keydown', (e)=>{
    const key = e.key.toLowerCase();
    // Start from overlay with Enter or Space
    if (!gameRunning && !overlay.hidden && (key === 'enter' || key === ' ')){
      e.preventDefault(); newGame(); startGame(); return;
    }
    if (['a','d','w','arrowleft','arrowright','arrowup'].includes(key)) keys[key]=true;
    if (gameRunning && (key===' ' || key==='w' || key==='arrowup')){ e.preventDefault(); player.jump(); }
    if (key==='r'){ location.reload(); } // exact refresh
  });
  window.addEventListener('keyup', (e)=>{
    const k = e.key.toLowerCase();
    if (['a','d','w','arrowleft','arrowright','arrowup'].includes(k)) keys[k]=false;
  });

  // ------------ Overlay wiring ------------
  overlay.hidden = false;
  chooseEl.addEventListener('click',(e)=>{
    const card = e.target.closest('.card'); if(!card) return;
    [...chooseEl.querySelectorAll('.card')].forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected'); hero = card.dataset.hero;
  });
  document.getElementById('startBtn').addEventListener('click', ()=>{ newGame(); startGame(); });
  document.getElementById('restartBtn').addEventListener('click', ()=>{ location.reload(); });
})();
</script>
</body>
</html>